(* Placeholder for the dating-client. Note that in order to communicate 
   with your server you will need to create the corresponding trustmap *)
   
import stdio
import lists
import declassifyutil

let 
    fun loop () =
                let  val _ = print "Waiting for response..."
                    val newResponse = receive [hn ("NEWMATCH", newResponse) => newResponse]
                    val _ = print(newResponse)
                in loop ()
                end
    fun agent profile_b = 
      let 
        (*val decprofile = declassifydeep(profile_b, authority, `{}`)*)
        val (lev_b,name_b,age_b,gender_b,interests_b) = profile_b

        val lev = `{alice}`
        val name = "Alice" raisedTo lev_b
        val year = 2002 raisedTo lev_b
        val gender = true raisedTo lev_b
        val interests = ["wine","summer"] raisedTo lev_b
        val profile = (lev,name,year,gender,interests)

       (*val newfile = declassifydeep(profile_b,authority,`{}`)

        val _ = send(pid,("NEWMATCH",profile_b))*) 

        val preference = true raisedTo lev_b
        val maybeProfile = profile raisedTo lev_b
      in 
        (preference,maybeProfile)
      end
    fun clientAlice serverid =
      let 
         val lev = `{alice}`
         val name = "Alice" raisedTo lev
         val year = 2002 raisedTo lev
         val gender = true raisedTo lev
         val interests = ["wine","summer"] raisedTo lev
         val profile = (lev,name,year,gender,interests)
         val test = agent profile
         val _ = send(serverid,("NEWPROFILE",(profile,agent,self())))
         
         (*val _ = printWithLabels(profile)
         val _ = printWithLabels(test)
         *)
         val _ = print "SENT"
      in loop()
      end
   val serverid = whereis("QmNzXPVyMYojkfP8JjVqwy4NWbqYyovThEk3bkK4t4Ny6a","datingServer")
in spawn (fn() => clientAlice serverid)
end